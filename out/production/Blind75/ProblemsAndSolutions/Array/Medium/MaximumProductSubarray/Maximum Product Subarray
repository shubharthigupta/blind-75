## ğŸ§  Maximum Product Subarray

---

### ğŸ“˜ Problem Statement:

> Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the **largest product**, and return its product.


### ğŸ“Œ Example:

```java
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product = 6

Input: nums = [-2,0,-1]
Output: 0
Explanation: The result is 0, not 2, because the subarray must be contiguous.
```


### ğŸ”’ Constraints:

* `1 <= nums.length <= 2 * 10â´`
* `-10 <= nums[i] <= 10`
* The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.

---

## âœ… Key Idea:

Use a **modified version of Kadaneâ€™s Algorithm** by tracking both the **maximum and minimum product** at each step:

1. Negative numbers can flip the max into a min and vice versa.
2. For each number:

    * Track the current max and min products.
    * Compute:
      `tempMax = max(num, num * maxSoFar, num * minSoFar)`
      `tempMin = min(num, num * maxSoFar, num * minSoFar)`
3. Update the global maximum from `tempMax`.


## ğŸ’¡ Notes to Memorize:

* Maintain two variables at each step:

    * `maxSoFar`: max product ending at current index
    * `minSoFar`: min product ending at current index
* Swap values when encountering a **negative number**.
* Always compare current number by itself (start new subarray).


### ğŸ› ï¸ High-Level Steps:

* Initialize:

    * `maxProduct = nums[0]`
    * `minSoFar = maxSoFar = nums[0]`
* Traverse from index 1 to end:

    * If `nums[i] < 0`, **swap** `maxSoFar` and `minSoFar`
    * Update `maxSoFar = max(nums[i], nums[i] * maxSoFar)`
    * Update `minSoFar = min(nums[i], nums[i] * minSoFar)`
    * Update `maxProduct = max(maxProduct, maxSoFar)`
* Return `maxProduct`


### â±ï¸ Time and Space Complexity:

* **Time Complexity**: `O(n)` â€” One pass through the array
* **Space Complexity**: `O(1)` â€” Constant space used
