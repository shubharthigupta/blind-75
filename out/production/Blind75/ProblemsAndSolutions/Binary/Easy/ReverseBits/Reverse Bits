## ğŸ§  Reverse Bits

---

### ğŸ“˜ Problem Statement:

> Reverse bits of a given **32 bits unsigned integer** and return the resulting integer.


### ğŸ“Œ Example:

```java
Input: n = 00000010100101000001111010011100
Output:    00111001011110000010100101000000
Explanation: The input is `43261596` and the output is `964176192`

Input: n = 11111111111111111111111111111101
Output:    10111111111111111111111111111111
Explanation: Input is `4294967293`, Output is `3221225471`
```


### ğŸ”’ Constraints:

* The input must be treated as an **unsigned 32-bit integer**.
* The return value must also be a **32-bit unsigned integer**.

---

## âœ… Key Idea:

Reverse the bits by reading each bit from right to left and constructing the result from left to right using bitwise operations.


## ğŸ’¡ Notes to Memorize:

* Use a **loop for 32 iterations** (since input is 32 bits).
* In each iteration:

    * Left shift the result: `res <<= 1`
    * If the last bit of `n` is 1 (`n & 1`), add it to result: `res |= 1`
    * Right shift `n`: `n >>>= 1` (use **unsigned shift**)
* Works for both positive and negative numbers in Java because we're using unsigned logic.


### ğŸ› ï¸ High-Level Steps:

1. Initialize `res = 0`
2. Repeat 32 times:

    * Left shift `res` by 1
    * Add the last bit of `n` to `res` (`res |= n & 1`)
    * Unsigned right shift `n` by 1 (`n >>>= 1`)
3. Return `res`


### â±ï¸ Time and Space Complexity:

| Type     | Complexity                    |
| -------- | ----------------------------- |
| â³ Time   | `O(1)` â€” always 32 iterations |
| ğŸ§  Space | `O(1)` â€” constant space       |
