## ğŸ§  Counting Bits

---

### ğŸ“˜ Problem Statement:

> Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (where `0 <= i <= n`), `ans[i]` is the **number of 1's** in the **binary representation** of `i`.

### ğŸ“Œ Example:

```java
Input: n = 2
Output: [0, 1, 1]
// Explanation: 
// 0 â†’ 0 â†’ 0 bits
// 1 â†’ 1 â†’ 1 bit
// 2 â†’ 10 â†’ 1 bit

Input: n = 5
Output: [0, 1, 1, 2, 1, 2]
```

### ğŸ”’ Constraints:

* `0 <= n <= 10âµ`

---

## âœ… Key Idea:

Use **dynamic programming with bit patterns**. The number of 1s in a number `i` is:

> `ans[i] = ans[i >> 1] + (i & 1)`

Explanation:

* `i >> 1` is `i` divided by 2 (essentially dropping the last bit).
* `(i & 1)` checks if the last bit is 1 or 0.
* This means you can build up the result using previous values in the `ans` array.

## ğŸ’¡ Notes to Memorize:

* Think recursively:

    * `countBits(i) = countBits(i / 2) + (i % 2)`
* Avoid recomputing â€” store intermediate results in an array.
* This uses the **binary structure** of numbers effectively.


### ğŸ› ï¸ High-Level Steps:

* Create an array `ans` of size `n + 1`.
* Initialize `ans[0] = 0`
* For each `i` from `1` to `n`:

    * `ans[i] = ans[i >> 1] + (i & 1)`
* Return the array `ans`

### â±ï¸ Time and Space Complexity:

| Type     | Complexity                                         |
| -------- | -------------------------------------------------- |
| â³ Time   | `O(n)` â€” linear scan through all numbers up to `n` |
| ğŸ§  Space | `O(n)` â€” result array of size `n + 1`              |

