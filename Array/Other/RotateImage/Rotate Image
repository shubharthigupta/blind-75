## ğŸ§  Rotate Image

---

### ğŸ“˜ Problem Statement:

> You are given an `n x n` 2D matrix representing an image.
> Rotate the image **90 degrees clockwise**.
>
> âš ï¸ The rotation must be done **in-place**, without using any additional 2D matrix.

---

### ğŸ“Œ Example:

```
Input:
matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]

Output:
[
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
```

---

### ğŸ’¡ Core Idea (Layer-by-Layer Rotation):

Instead of using transpose + reverse, this solution rotates the matrix **layer by layer**.

* Treat the matrix as a set of **concentric squares (layers)**
* Rotate one layer at a time, starting from the **outermost layer**
* For each layer, perform a **4-way element swap**

This approach directly simulates the rotation process.

---

### ğŸ§© High-Level Approach:

1. Validate that the matrix is **non-empty and square**
2. Iterate through each **layer** (from outer to inner)
3. For each layer:

    * Identify the **first** and **last** index
    * Rotate elements in groups of four

---

### ğŸ”„ Understanding the 4-Way Swap:

For a given layer:

```
Top    â†’ Right
Left   â†’ Top
Bottom â†’ Left
Right  â†’ Bottom
```

This rotation is achieved using a temporary variable.

---

### ğŸ› ï¸ Step-by-Step Breakdown:

#### ğŸ”¹ Step 1: Matrix Validation

```java
if(matrix.length == 0 || matrix.length != matrix[0].length) return;
```

* Ensures the matrix is square (`n x n`)
* Prevents invalid operations

---

#### ğŸ”¹ Step 2: Iterate Over Layers

```java
for(int layer = 0; layer < matrix.length / 2; layer++) {
    int first = layer;
    int last = matrix.length - 1 - layer;
}
```

* Only `n/2` layers exist in an `n x n` matrix
* `first` and `last` define the boundaries of the current layer

---

#### ğŸ”¹ Step 3: Rotate Elements Within a Layer

```java
for(int i = first; i < last; i++) {
    int offset = i - first;
    int temp = matrix[first][i];

    matrix[first][i] = matrix[last - offset][first];
    matrix[last - offset][first] = matrix[last][last - offset];
    matrix[last][last - offset] = matrix[i][last];
    matrix[i][last] = temp;
}
```

**What happens here:**

* Save the **top** element
* Move **left â†’ top**
* Move **bottom â†’ left**
* Move **right â†’ bottom**
* Assign saved top â†’ **right**

Each iteration rotates one group of four elements.

---

### ğŸ§  Visual Intuition (Single Rotation):

```
(0,0) â† (2,0) â† (2,2) â† (0,2)
```

This operation is repeated for all elements in the layer.

---

### âš ï¸ Points to Remember:

* The matrix must be **square**
* Always rotate **layer by layer**
* Each layer requires multiple **4-way swaps**
* Use a temporary variable to avoid data loss
* Only iterate until `n / 2` layers

---

### â±ï¸ Time and Space Complexity:

* **Time Complexity**: `O(nÂ²)` â€” Every element is moved once
* **Space Complexity**: `O(1)` â€” In-place rotation

---

### âœ… Final Takeaway:

> This layer-by-layer approach closely mimics how a human would rotate an image.
> It is efficient, in-place, and ideal for interviews where extra space is restricted.

ğŸ’¡ **Remember:** Rotate **four elements at a time**, one layer at a time ğŸš€
