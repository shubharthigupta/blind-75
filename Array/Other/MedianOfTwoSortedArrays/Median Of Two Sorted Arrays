## ğŸ§  Median of Two Sorted Arrays

---

### ğŸ“˜ Problem Statement:

> You are given two **sorted arrays** `nums1` and `nums2` of sizes `m` and `n` respectively.
>
> Return the **median** of the two sorted arrays.
>
> âš ï¸ The overall runtime complexity must be **O(log (m + n))**.

---

### ğŸ“Œ What Is the Median?

* If the total number of elements is **odd** â†’ the median is the **middle element**
* If the total number of elements is **even** â†’ the median is the **average of the two middle elements**

---

### ğŸ“Œ Example:

```
nums1 = [1, 3]
nums2 = [2]

Output: 2.0
```

```
nums1 = [1, 2]
nums2 = [3, 4]

Output: 2.5
```

---

### ğŸ’¡ Core Idea (Binary Search on Partitions):

Instead of merging the arrays (which takes `O(m + n)` time), we:

* Perform **binary search on the smaller array**
* Partition both arrays such that:

    * Left half contains **half (or half + 1)** of total elements
    * All elements in the left half are **â‰¤** all elements in the right half

This allows us to compute the median directly.

---

### ğŸ§© Key Observations:

1. Always apply binary search on the **smaller array**
2. A correct partition satisfies:

    * `maxLeft1 â‰¤ minRight2`
    * `maxLeft2 â‰¤ minRight1`
3. Once the correct partition is found, the median can be computed in **constant time**

---

### ğŸ› ï¸ Step-by-Step Approach:

#### ğŸ”¹ Step 1: Ensure Binary Search on Smaller Array

```java
if(nums1.length > nums2.length){
    return findMedianSortedArrays(nums2, nums1);
}
```

* Guarantees `O(log(min(m, n)))` complexity
* Simplifies boundary handling

---

#### ğŸ”¹ Step 2: Define Search Space

```java
int m = nums1.length;
int n = nums2.length;
int left = 0, right = m;
```

* We search over the indices of `nums1`
* Each index represents a possible partition

---

#### ğŸ”¹ Step 3: Binary Search for Correct Partition

```java
int part1 = (left + right) / 2;
int part2 = ((m + n + 1) / 2) - part1;
```

* `part1` â†’ partition in `nums1`
* `part2` â†’ corresponding partition in `nums2`
* Ensures left half has the required number of elements

---

#### ğŸ”¹ Step 4: Handle Boundary Conditions

```java
int maxLeft1 = part1 == 0 ? Integer.MIN_VALUE : nums1[part1 - 1];
int minRight1 = part1 == m ? Integer.MAX_VALUE : nums1[part1];

int maxLeft2 = part2 == 0 ? Integer.MIN_VALUE : nums2[part2 - 1];
int minRight2 = part2 == n ? Integer.MAX_VALUE : nums2[part2];
```

* Handles cases where partitions touch array boundaries
* Prevents index out-of-bounds errors

---

#### ğŸ”¹ Step 5: Check for Valid Partition

```java
if(maxLeft1 <= minRight2 && maxLeft2 <= minRight1){
    // Correct partition found
}
```

This condition guarantees:

> All elements on the left side are less than or equal to those on the right side

---

#### ğŸ”¹ Step 6: Compute the Median

```java
if((m + n) % 2 == 0){
    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;
} else {
    return Math.max(maxLeft1, maxLeft2);
}
```

* **Even total length** â†’ average of two middle values
* **Odd total length** â†’ max of left partition

---

#### ğŸ”¹ Step 7: Adjust Binary Search

```java
else if (maxLeft1 > minRight2) {
    right = part1 - 1;
} else {
    left = part1 + 1;
}
```

* Move left or right based on partition validity

---

### ğŸ§  Visual Intuition:

```
Left Partitions        | Right Partitions
-----------------------|------------------
maxLeft1  maxLeft2    | minRight1 minRight2
```

The median lies **between these boundary elements**.

---

### âš ï¸ Points to Remember:

* Always binary search the **smaller array**
* Correct partition satisfies **two inequalities**
* Use `Integer.MIN_VALUE` and `Integer.MAX_VALUE` for boundaries
* Do **not merge** the arrays
* Time complexity must remain logarithmic

---

### â±ï¸ Time and Space Complexity:

* **Time Complexity**: `O(log(min(m, n)))`
* **Space Complexity**: `O(1)` â€” no extra space used

---

### âœ… Final Takeaway:

> This is a classic **binary search on answer space** problem.
> Once you understand partitions, the solution becomes systematic and elegant.

ğŸ’¡ **Remember:** You are not searching for the median directly â€” you are searching for the **correct partition** ğŸš€
